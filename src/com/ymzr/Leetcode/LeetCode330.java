package com.ymzr.Leetcode;

/**
 * 给定一个已排序的正整数数组 nums，和一个正整数n 。从[1, n]区间内选取任意个数字补充到nums中，使得[1, n]区间内的任何数字都可以用nums中某几个数字的和来表示。
 *
 * 请返回 满足上述要求的最少需要补充的数字个数。
 *
 * 
 *
 * 示例1:
 *
 * 输入: nums = [1,3], n = 6
 * 输出: 1 
 * 解释:
 * 根据 nums里现有的组合[1], [3], [1,3]，可以得出1, 3, 4。
 * 现在如果我们将2添加到nums 中，组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
 * 其和可以表示数字1, 2, 3, 4, 5, 6，能够覆盖[1, 6]区间里所有的数。
 * 所以我们最少需要添加一个数字。
 * 示例 2:
 *
 * 输入: nums = [1,5,10], n = 20
 * 输出: 2
 * 解释: 我们需要添加[2,4]。
 * 示例3:
 *
 * 输入: nums = [1,2,2], n = 5
 * 输出: 0
 *
 */
public class LeetCode330 {

    //如果我有砝码0，能称的重量为0
    //再加一个砝码1，能称的重量不到2    1
    //再加一个砝码2，能称的重量不到4    1    1+2
    //再加一个砝码4，能称的重量不到8    1    2    1+2    4  1+4    1+2+4
    //再加一个砝码8，能称的重量不到16（16以内的全都能称出来）
    //因为我每次前一步已经完全覆盖[0，n),再加一个n kg的不就能覆盖[0，2n)了吗。
    //同时为了加的次数最少我们才这样加，不需要1，2，3，4，5.....每种砝码都有。
    //只有这样先做到局部加砝码最少，才能保证到后边n很大时加的砝码最少
    public static int minPatches(int[] nums, int n) {
        int counts = 0;
        int length = nums.length;
        int index = 0;
        int sums = 1;
        while (sums <= n) {
            if (index < length && nums[index] <= sums) {
                sums += nums[index];
                index++;
            //上面判断语句可能不好理解，若现有砝码1, 4, 6, n为10，当一次循环后砝码1已计入x,x=2，但是nums[1]=4>2;
            //这说明断码了，我们需要的是重量为x=2的砝码，所以加一个，现在能称的重量就能覆盖到原来的2倍=4了（不到4）
            //然后nums[1]=4就等于4，4的砝码我们刚好有，加进来，现在能称的重量就能覆盖到原来的2倍=8了（不到8）
            //然后nums[2]=6<8，这个不是必需的砝码，加进来，现在能称的重量就能覆盖到8+6=14了（不到14）
            } else {
                sums *= 2;
                counts++;
            }
        }
        return counts;
    }

    public static int minPatches2(int[] nums, int n) {
        long x = 0;
        int i = 0;
        int res = 0;
        while (x < n) {
            if (i < nums.length &&  nums[i] <= x + 1 ) {
                x += nums[i++];
            } else {
                x = x + (x + 1);
                res++;
            }
        }

        return res;
    }

    public static void main(String[] args) {
        int[] nums = {1,2,31,33};
        System.out.println(minPatches(nums,20));
        System.out.println(minPatches2(nums,2147483647));
    }


    /**
     * 假设，当前数组nums的下标为j，且我们通过填充数组，已经使得数组前j-1个元素具有表达范围[1 ~ x]的能力。那么我们可以根据nums[j]和x作出如下判断：
     *
     * nums[j] <= x + 1: 说明nums[j]前面的所有整数，已经能通过数组前j-1个数中的几个数组合出来。又因为nums[j]与[1 ~ x]是连着的（nums[j] 如果等于 x+1，那么就与区间 [1 ~ x] 挨着在，如果小于 x+1，那么就在区间 [1 ~ x]中。），所以在当前下标j处，我们可以把前j个元素的表达范围记作[1 ~ x+nums[j]]，这整个区间内是没有“窟窿”的。
     * nums[j] > x + 1: 说明x+1到nums[j]的整数不能数组前j-1个数表达，所以我们不能贸然把表达范围扩充到[1 ~ x+nums[j]]。因为在这个范围内，还有[(x+1) ~ (nums[j]-1)]这些“窟窿”没填上。那么当出现这种情况时，我们需要填入x+1，把这个“窟窿”补上，并且可以把这个数加到表达范围上得到[1 ~ x+(x+1)]，同时记录次数。据此不断循环，直到中间的窟窿被补完，从而转移到上一种情况进行处理。
     * 可以结合下图理解
     *
     *
     *                      hole
     *               +----+     +---+
     *               +              +
     *
     *               x+1     nums[j]-1
     * +-----------^--v-------------v--^-------------------+
     * 1           x                  nums[j]           x+nums[j]
     *
     * +           +                   +                   +
     * +---+   +---+                   +-------+    +------+
     *   exp range                           exp range
     *
     *
     * 当表达范围达到[1~n]时，就可以跳出循环，返回结果了
     *
     */
}
