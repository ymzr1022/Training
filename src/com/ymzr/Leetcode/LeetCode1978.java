package com.ymzr.Leetcode;

import java.util.Arrays;

/**
 * 给你一个长度为 n的整数数组coins，它代表你拥有的n个硬币。第i个硬币的值为coins[i]。如果你从这些硬币中选出一部分硬币，它们的和为x，那么称，你可以构造出x。
 *
 * 请返回从 0开始（包括0），你最多能构造出多少个连续整数。
 *
 * 你可能有多个相同值的硬币。
 *
 * 
 *
 * 示例 1：
 *
 * 输入：coins = [1,3]
 * 输出：2
 * 解释：你可以得到以下这些值：
 * - 0：什么都不取 []
 * - 1：取 [1]
 * 从 0 开始，你可以构造出 2 个连续整数。
 * 示例 2：
 *
 * 输入：coins = [1,1,1,4]
 * 输出：8
 * 解释：你可以得到以下这些值：
 * - 0：什么都不取 []
 * - 1：取 [1]
 * - 2：取 [1,1]
 * - 3：取 [1,1,1]
 * - 4：取 [4]
 * - 5：取 [4,1]
 * - 6：取 [4,1,1]
 * - 7：取 [4,1,1,1]
 * 从 0 开始，你可以构造出 8 个连续整数。
 * 示例 3：
 *
 * 输入：nums = [1,4,10,3,1]
 * 输出：20
 *
 */
public class LeetCode1978 {

    public int getMaximumConsecutive(int[] coins) {
        Arrays.sort(coins);
        int max = 0;
        for (int n : coins) {
            if (n <= max + 1) {
                max += n;
            }
        }
        return max + 1;
    }

    public static void main(String[] args) {
        LeetCode1978 leetCode1978 = new LeetCode1978();
        int[] nums = {1,4,10,3,1};
        System.out.println(leetCode1978.getMaximumConsecutive(nums));
    }
}

/**
 这是一道非常经典的贪心题。330.按要求补齐数组可以视为它的进阶。事实上两题思路基本相同。

 思路
 本题的思路有种数学归纳法的感觉。需要考虑的就是这样一个问题：

 当我们已经可以表示[0,n]时，再给一个整数x，可以表示的整数范围如何变化？
 显然，新增的可达数就是把原来的n+1个数都加上x，得到[x,n+x]，新的可以表示的数的范围就是这两部分的并集。在本题中，要求可达域连续，也就是要求x<=n+1，这样可达域就被扩充为[0,n+x]。

 初始可达域为{0}，由于x<=n+1的条件限制，我们肯定是从小到大地添加数。我们维护当前可以表示的最大值，也就是上面的n，如果当前最小数满足条件，就添加之，并更新最大值；否则就没有有可以添加的数了，返回答案。

 */